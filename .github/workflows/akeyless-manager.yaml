name: Fetch Akeyless Static Secret (JWT/OIDC)

# Controls when the workflow is triggered: on a manual run
on:
  workflow_dispatch:
    inputs:
      reason:
        description: 'Optional: Reason for running the workflow'
        required: false
        default: 'Manual trigger for Akeyless test'

jobs:
  fetch_and_use_secret:
    runs-on: ubuntu-latest
    
    # ðŸš¨ REQUIRED for JWT/OIDC authentication 
    # This grants permission to GitHub to issue the OIDC token
    permissions:
      id-token: write  # Crucial for Akeyless to verify the workflow's identity
      contents: read   # Allows the checkout step to work

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Fetch 'secrets/MysecondSecret' from Akeyless
        uses: akeyless-community/akeyless-github-action@v1.1.2 
        id: fetch-secrets
        with:
          # The public identifier for your Akeyless Auth Method (Stored as a GitHub Variable)
          access-id: ${{ vars.AKEYLESS_ACCESS_ID }} 
          
          # Recommended Auth Type: JWT (uses the GitHub OIDC token)
          access-type: jwt 
          
          # Explicitly set the Akeyless API URL for clarity
          api-url: https://api.akeyless.io
          
          # IMPORTANT FIX: This breaks the structured secret (JSON/YAML) into 
          # individual environment variables (e.g., MY_SECOND_SECRET_USERNAME)
          parse-json-secrets: true

          # Specify the list of static secrets to fetch
          static-secrets: |
            # Path to the secret in Akeyless
            - name: "secrets/MysecondSecret"
              # Prefix for environment variables: MY_SECOND_SECRET_
              output-name: "MY_SECOND_SECRET" 
      
      # --- USAGE STEP ---
      # This step consumes the individual secret values fetched by the previous action.
      - name: Process and Use the Secret Values
        run: |
          echo "--- Processing Secrets ---"
          
          # Access the individual keys using the format: ${{ env.OUTPUT_NAME_KEY }}
          USERNAME="${{ env.MY_SECOND_SECRET_USERNAME }}"
          PASSWORD="${{ env.MY_SECOND_SECRET_PASSWORD }}"
          
          # Example: Log the username for debugging (password is masked by default)
          echo "Username successfully retrieved: $USERNAME"
          
          # Example: Use the secrets to log into a service (e.g., Docker registry)
          # DO NOT echo passwords. Use them directly in a command like this:
          # docker login my.registry.com -u "$USERNAME" -p "$PASSWORD"
          
          echo "Secrets are ready for use in subsequent commands."